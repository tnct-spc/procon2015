#define BOOST_TEST_MAIN
#include <boost/test/included/unit_test.hpp>

#include <iostream>
#include <type_traits>

// こうするとプライベートメンバ関数のテストができるぞい
#define private public
#include "data_type.hpp"

namespace boost {
    namespace test_tools {
        template <template <class...> class T, typename U>
        struct print_log_value<T<U>> {
            template <typename CharT, typename Traits>
            void operator()(std::basic_ostream<CharT, Traits> & os,
                            std::enable_if_t<std::is_same<typename T<U>::value_type, U>::value, T<U>> const& container)
            {
                for (auto && element : container) {
                    os << element << std::endl;
                }
            }
        };
    }
}

namespace {
    BOOST_AUTO_TEST_SUITE(problem_type_tests)

        auto problem_text = "\
00000000000000001111111111111111\r\n\
00000000000000001111111111111111\r\n\
01000000000000001111111111111111\r\n\
00000000000000001111111111111111\r\n\
00000000000000001111111111111111\r\n\
00000000000000001111111111111111\r\n\
00000000000000001111111111111111\r\n\
00000100000000001111111111111111\r\n\
00000000000000001111111111111111\r\n\
00000000000000001111111111111111\r\n\
00000000000000001111111111111111\r\n\
00000000010000001111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
\r\n\
4\r\n\
01000000\r\n\
01000000\r\n\
01000000\r\n\
01000000\r\n\
01000000\r\n\
01000000\r\n\
01110000\r\n\
00000000\r\n\
\r\n\
00000000\r\n\
01100000\r\n\
01100000\r\n\
01100000\r\n\
01100000\r\n\
00000000\r\n\
00000000\r\n\
00000000\r\n\
\r\n\
00000000\r\n\
00010000\r\n\
00010000\r\n\
01111000\r\n\
00000000\r\n\
00000000\r\n\
00000000\r\n\
00000000\r\n\
\r\n\
10000000\r\n\
11000000\r\n\
01100000\r\n\
00110000\r\n\
00011000\r\n\
00001100\r\n\
00000110\r\n\
00000011";

    BOOST_AUTO_TEST_CASE(_split_problem_text_test)
    {
        decltype(problem_type::_split_problem_text(problem_text)) expected, result;
        expected = std::make_tuple(
"00000000000000001111111111111111\r\n\
00000000000000001111111111111111\r\n\
01000000000000001111111111111111\r\n\
00000000000000001111111111111111\r\n\
00000000000000001111111111111111\r\n\
00000000000000001111111111111111\r\n\
00000000000000001111111111111111\r\n\
00000100000000001111111111111111\r\n\
00000000000000001111111111111111\r\n\
00000000000000001111111111111111\r\n\
00000000000000001111111111111111\r\n\
00000000010000001111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111\r\n\
11111111111111111111111111111111", 
std::vector<std::string>({
"01000000\r\n\
01000000\r\n\
01000000\r\n\
01000000\r\n\
01000000\r\n\
01000000\r\n\
01110000\r\n\
00000000",
"00000000\r\n\
01100000\r\n\
01100000\r\n\
01100000\r\n\
01100000\r\n\
00000000\r\n\
00000000\r\n\
00000000",
"00000000\r\n\
00010000\r\n\
00010000\r\n\
01111000\r\n\
00000000\r\n\
00000000\r\n\
00000000\r\n\
00000000",
"10000000\r\n\
11000000\r\n\
01100000\r\n\
00110000\r\n\
00011000\r\n\
00001100\r\n\
00000110\r\n\
00000011"}));
        result = problem_type::_split_problem_text(problem_text);
        BOOST_CHECK_EQUAL(std::get<0>(expected), std::get<0>(result));
        BOOST_CHECK_EQUAL(std::get<1>(expected), std::get<1>(result));
    }

    BOOST_AUTO_TEST_CASE(constructor_test)
    {
        BOOST_CHECK_NO_THROW(problem_type(problem_text));
    }

    BOOST_AUTO_TEST_CASE(_split_test)
    {
        auto sample = "123,,456,,789,,12,34,56,78,90,,abc,,def,,ghi,,,,,"s;
        std::vector<std::string> result = problem_type::_split(sample, ",,"s);
        decltype(result) expected = {"123"s,"456"s,"789"s, "12,34,56,78,90"s, "abc"s, "def"s, "ghi"s, ""s, ","s};
        BOOST_CHECK_EQUAL(expected, result);
    }

    BOOST_AUTO_TEST_SUITE_END()
}
